# -*- coding: utf-8 -*-
"""Ablation Architecture 1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-X7-Xz8OKaMQaMQkk_pHk6oLLsjREP_6
"""

@keras.saving.register_keras_serializable()
def sinusoidal_embedding(x):
    embedding_min_frequency = 1.0
    embedding_max_frequency = 1000.0
    frequencies = ops.exp(
        ops.linspace(
            ops.log(embedding_min_frequency),
            ops.log(embedding_max_frequency),
            embedding_dims // 2,
        )
    )
    angular_speeds = ops.cast(2.0 * math.pi * frequencies, "float32")
    embeddings = ops.concatenate(
        [ops.sin(angular_speeds * x), ops.cos(angular_speeds * x)], axis=3
    )
    return embeddings

def ResidualBlock(width):
    def apply(x):
        input_width = x.shape[3]
        if input_width == width:
            residual = x
        else:
            residual = layers.Conv2D(width, kernel_size=1)(x)
        x = layers.BatchNormalization(center=True, scale=True)(x)
        x = layers.Conv2D(width, kernel_size=3, padding="same", activation="relu")(x)
        x = layers.Conv2D(width, kernel_size=3, padding="same")(x)
        x = layers.Add()([x, residual])
        return x
    return apply

def get_network(image_size, widths, block_depth):
    # Inputs
    input_image = keras.Input(shape=(image_size, image_size, 3))
    noise_variances = keras.Input(shape=(1, 1, 1))

    # Time embedding
    e = layers.Lambda(sinusoidal_embedding)(noise_variances)
    e = layers.UpSampling2D(size=image_size, interpolation="nearest")(e)

    # Dual Encoder Structure
    x_left = layers.Conv2D(widths[0], 3, padding='same')(input_image)
    x_left = layers.Concatenate()([x_left, e])
    x_left = layers.Conv2D(widths[0], 3, padding='same')(x_left)

    x_bottom = layers.Conv2D(widths[0], 5, padding='same')(input_image)
    x_bottom = layers.Concatenate()([x_bottom, e])
    x_bottom = layers.Conv2D(widths[0], 5, padding='same')(x_bottom)

    skips = []

    # Process both encoders
    for width in widths[:-1]:
        x_left = ResidualBlock(width)(x_left)
        skips.append(x_left)
        x_left = layers.AveragePooling2D(2)(x_left)
        x_left = layers.Conv2D(width, 3, padding='same')(x_left)

        x_bottom = ResidualBlock(width)(x_bottom)
        skips.append(x_bottom)
        x_bottom = layers.AveragePooling2D(2)(x_bottom)
        x_bottom = layers.Conv2D(width, 5, padding='same')(x_bottom)

    # Bottleneck
    x = layers.Concatenate()([x_left, x_bottom])
    x = layers.Conv2D(widths[-1], 1, padding='same')(x)

    for _ in range(block_depth):
        x = ResidualBlock(widths[-1])(x)

    # Single Decoder
    for width in reversed(widths[:-1]):
        x = layers.UpSampling2D(2, interpolation='bilinear')(x)
        skip = layers.Concatenate()([skips.pop(), skips.pop()])
        x = layers.Concatenate()([x, skip])
        x = ResidualBlock(width)(x)

    # Output noise prediction
    output = layers.Conv2D(3, 1, kernel_initializer='zeros')(x)
    return keras.Model([input_image, noise_variances], output, name="arch_1")