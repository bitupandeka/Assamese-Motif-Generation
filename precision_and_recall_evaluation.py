# -*- coding: utf-8 -*-
"""Precision and Recall Evaluation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1F-HT7ldpj_d_a0TlNFMB0MZZzWCVzWIc
"""

import numpy as np
import tensorflow as tf
from tensorflow.keras.applications.inception_v3 import InceptionV3, preprocess_input
from scipy.spatial import distance
import os

# Function to load real images from dataset
def load_real_images(directory, num_images=506):
    image_paths = [os.path.join(directory, fname)
                   for fname in os.listdir(directory)
                   if fname.endswith(('.jpg', '.png'))][:num_images]

    real_images = []
    for path in image_paths:
        image = tf.io.read_file(path)
        image = tf.image.decode_jpeg(image, channels=3)  # Adjust for PNG if needed
        image = tf.image.resize(image, [image_size, image_size], antialias=True)
        image = tf.clip_by_value(image / 255.0, 0.0, 1.0)
        real_images.append(image)

    return tf.stack(real_images)

# Function to extract InceptionV3 features
def get_inception_features(images, batch_size=32):
    # Load InceptionV3 model
    inception_model = InceptionV3(include_top=False, pooling='avg', input_shape=(299, 299, 3))

    # Preprocess images for InceptionV3
    images = tf.image.resize(images, [299, 299])  # Resize to InceptionV3 input size
    images = preprocess_input(images * 255.0)  # Scale to [-1, 1] as expected by InceptionV3

    # Extract features in batches
    features = []
    for i in range(0, len(images), batch_size):
        batch = images[i:i + batch_size]
        batch_features = inception_model.predict(batch, verbose=0)
        features.append(batch_features)

    return np.concatenate(features, axis=0)

# Function to compute precision and recall
def compute_precision_recall(real_features, generated_features, k=3):
    # Compute pairwise distances
    distances_real = distance.cdist(real_features, real_features, 'euclidean')
    distances_gen_to_real = distance.cdist(generated_features, real_features, 'euclidean')

    # Sort distances to find k-th nearest neighbor
    real_kth_distances = np.sort(distances_real, axis=1)[:, k]

    # Precision: Proportion of generated samples that fall within the real manifold
    precision = np.mean([
        np.min(distances_gen_to_real[i]) <= real_kth_distances[np.argmin(distances_gen_to_real[i])]
        for i in range(len(generated_features))
    ])

    # Recall: Proportion of real samples that fall within the generated manifold
    distances_real_to_gen = distance.cdist(real_features, generated_features, 'euclidean')
    gen_kth_distances = np.sort(distances_gen_to_real, axis=1)[:, k]
    recall = np.mean([
        np.min(distances_real_to_gen[i]) <= gen_kth_distances[np.argmin(distances_real_to_gen[i])]
        for i in range(len(real_features))
    ])

    return precision, recall

# Generate images and compute precision/recall
def evaluate_precision_recall(model, dataset_path, num_generated=1212, num_real=1212, batch_size=16):
    # Load real images
    print("Loading real images...")
    real_images = load_real_images(dataset_path, num_real)

    # Generate images
    print("Generating images...")
    generated_images = model.generate(num_images=num_generated, diffusion_steps=plot_diffusion_steps)

    # Extract features
    print("Extracting features for real images...")
    real_features = get_inception_features(real_images, batch_size)
    print("Extracting features for generated images...")
    generated_features = get_inception_features(generated_images, batch_size)

    # Compute precision and recall
    print("Computing precision and recall...")
    precision, recall = compute_precision_recall(real_features, generated_features, k=3)

    return precision, recall

# After training, compute precision and recall
dataset_path = dataset_path  # Replace with your dataset path
precision, recall = evaluate_precision_recall(
    model,
    dataset_path,
    num_generated=1212,
    num_real=1212,
    batch_size=16
)
print(f"Precision: {precision:.4f}")
print(f"Recall: {recall:.4f}")